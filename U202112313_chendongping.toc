\contentsline {section}{\numberline {1}基于顺序存储结构的线性表实现}{1}{section.1}%
\contentsline {subsection}{\numberline {1.1}问题描述}{1}{subsection.1.1}%
\contentsline {subsection}{\numberline {1.2}系统设计}{2}{subsection.1.2}%
\contentsline {subsubsection}{\numberline {1.2.1}整体系统结构设计}{2}{subsubsection.1.2.1}%
\contentsline {subsubsection}{\numberline {1.2.2}数据结构设计}{3}{subsubsection.1.2.2}%
\contentsline {subsection}{\numberline {1.3}系统实现}{4}{subsection.1.3}%
\contentsline {subsubsection}{\numberline {1.3.1}新建线性表（InitList）}{4}{subsubsection.1.3.1}%
\contentsline {subsubsection}{\numberline {1.3.2}销毁线性表（DestroyList）}{5}{subsubsection.1.3.2}%
\contentsline {subsubsection}{\numberline {1.3.3}清空线性表（ClearList）}{5}{subsubsection.1.3.3}%
\contentsline {subsubsection}{\numberline {1.3.4}线性表判空（ListEmpty）}{5}{subsubsection.1.3.4}%
\contentsline {subsubsection}{\numberline {1.3.5}求线性表长度（ListLength）}{5}{subsubsection.1.3.5}%
\contentsline {subsubsection}{\numberline {1.3.6}获取元素（GetElem(）}{5}{subsubsection.1.3.6}%
\contentsline {subsubsection}{\numberline {1.3.7}获取元素位置（LocateElem）}{6}{subsubsection.1.3.7}%
\contentsline {subsubsection}{\numberline {1.3.8}查找前驱（PriorElem）}{6}{subsubsection.1.3.8}%
\contentsline {subsubsection}{\numberline {1.3.9}查找后继（NextElem）}{7}{subsubsection.1.3.9}%
\contentsline {subsubsection}{\numberline {1.3.10}插入元素（ListInsert）}{7}{subsubsection.1.3.10}%
\contentsline {subsubsection}{\numberline {1.3.11}删除元素（ListDelete）}{8}{subsubsection.1.3.11}%
\contentsline {subsubsection}{\numberline {1.3.12}遍历线性表（ListTraverse）}{8}{subsubsection.1.3.12}%
\contentsline {subsubsection}{\numberline {1.3.13}最大连续子数组和（MaxSubArray）}{8}{subsubsection.1.3.13}%
\contentsline {subsubsection}{\numberline {1.3.14}寻找相等的子数组和（SubArrayNum）}{9}{subsubsection.1.3.14}%
\contentsline {subsubsection}{\numberline {1.3.15}线性表排序（SortList）}{9}{subsubsection.1.3.15}%
\contentsline {subsubsection}{\numberline {1.3.16}多线性表管理}{9}{subsubsection.1.3.16}%
\contentsline {subsubsection}{\numberline {1.3.17}文件的读写}{10}{subsubsection.1.3.17}%
\contentsline {subsubsection}{\numberline {1.3.18}线性表转移}{11}{subsubsection.1.3.18}%
\contentsline {subsection}{\numberline {1.4}系统测试}{12}{subsection.1.4}%
\contentsline {subsubsection}{\numberline {1.4.1}新建线性表（InitList）}{12}{subsubsection.1.4.1}%
\contentsline {subsubsection}{\numberline {1.4.2}销毁线性表（DestroyList）}{12}{subsubsection.1.4.2}%
\contentsline {subsubsection}{\numberline {1.4.3}清空线性表（ClearList）}{13}{subsubsection.1.4.3}%
\contentsline {subsubsection}{\numberline {1.4.4}求线性表长度（ListEmpty）}{13}{subsubsection.1.4.4}%
\contentsline {subsubsection}{\numberline {1.4.5}求线性表长度（ListLength）}{14}{subsubsection.1.4.5}%
\contentsline {subsubsection}{\numberline {1.4.6}获取元素（GetElem(）}{15}{subsubsection.1.4.6}%
\contentsline {subsubsection}{\numberline {1.4.7}获取元素位置（LocateElem）}{16}{subsubsection.1.4.7}%
\contentsline {subsubsection}{\numberline {1.4.8}查找前驱（PriorElem）}{17}{subsubsection.1.4.8}%
\contentsline {subsubsection}{\numberline {1.4.9}查找后继（NextElem）}{18}{subsubsection.1.4.9}%
\contentsline {subsubsection}{\numberline {1.4.10}插入元素（ListInsert）}{19}{subsubsection.1.4.10}%
\contentsline {subsubsection}{\numberline {1.4.11}删除元素（ListDelete）}{20}{subsubsection.1.4.11}%
\contentsline {subsubsection}{\numberline {1.4.12}遍历线性表（ListTraverse）}{21}{subsubsection.1.4.12}%
\contentsline {subsubsection}{\numberline {1.4.13}最大子数组和（MaxSubArray）}{22}{subsubsection.1.4.13}%
\contentsline {subsubsection}{\numberline {1.4.14}寻找相等的子数组和（SubArrayNum）}{23}{subsubsection.1.4.14}%
\contentsline {subsubsection}{\numberline {1.4.15}线性表排序（SortList）}{24}{subsubsection.1.4.15}%
\contentsline {subsubsection}{\numberline {1.4.16}多线性表管理}{25}{subsubsection.1.4.16}%
\contentsline {subsubsection}{\numberline {1.4.17}线性表排序（SortList）}{26}{subsubsection.1.4.17}%
\contentsline {subsubsection}{\numberline {1.4.18}文件的读写}{28}{subsubsection.1.4.18}%
\contentsline {subsubsection}{\numberline {1.4.19}退出程序}{30}{subsubsection.1.4.19}%
\contentsline {subsection}{\numberline {1.5}实验小结}{31}{subsection.1.5}%
\contentsline {section}{\numberline {2}基于二叉链表的二叉树实现}{32}{section.2}%
\contentsline {subsection}{\numberline {2.1}问题描述}{32}{subsection.2.1}%
\contentsline {subsection}{\numberline {2.2}系统设计}{34}{subsection.2.2}%
\contentsline {subsubsection}{\numberline {2.2.1}整体系统结构设计}{34}{subsubsection.2.2.1}%
\contentsline {subsubsection}{\numberline {2.2.2}数据结构设计}{35}{subsubsection.2.2.2}%
\contentsline {subsection}{\numberline {2.3}系统实现}{37}{subsection.2.3}%
\contentsline {subsubsection}{\numberline {2.3.1}创建二叉树（CreateBiTree）}{37}{subsubsection.2.3.1}%
\contentsline {subsubsection}{\numberline {2.3.2}销毁二叉树（DestroyBiTree）}{38}{subsubsection.2.3.2}%
\contentsline {subsubsection}{\numberline {2.3.3}清空二叉树（ClearBiTree）}{38}{subsubsection.2.3.3}%
\contentsline {subsubsection}{\numberline {2.3.4}判定空二叉树（BiTreeEmpty）}{38}{subsubsection.2.3.4}%
\contentsline {subsubsection}{\numberline {2.3.5}求二叉树深度（BiTreeDepth）}{38}{subsubsection.2.3.5}%
\contentsline {subsubsection}{\numberline {2.3.6}查找结点（LocateNode）}{39}{subsubsection.2.3.6}%
\contentsline {subsubsection}{\numberline {2.3.7}结点赋值（Assign）}{39}{subsubsection.2.3.7}%
\contentsline {subsubsection}{\numberline {2.3.8}获得兄弟结点（GetSibling）}{39}{subsubsection.2.3.8}%
\contentsline {subsubsection}{\numberline {2.3.9}插入结点（InsertNode）}{40}{subsubsection.2.3.9}%
\contentsline {subsubsection}{\numberline {2.3.10}删除结点（DeleteNode）}{40}{subsubsection.2.3.10}%
\contentsline {subsubsection}{\numberline {2.3.11}前序遍历（PreOrderTraverse）}{41}{subsubsection.2.3.11}%
\contentsline {subsubsection}{\numberline {2.3.12}中序遍历（InOrderTraverse）}{41}{subsubsection.2.3.12}%
\contentsline {subsubsection}{\numberline {2.3.13}后序遍历（PostOrderTraverse）}{41}{subsubsection.2.3.13}%
\contentsline {subsubsection}{\numberline {2.3.14}按层遍历（LevelOrderTraverse）}{42}{subsubsection.2.3.14}%
\contentsline {subsubsection}{\numberline {2.3.15}最大路径和（MaxPathSum）}{42}{subsubsection.2.3.15}%
\contentsline {subsubsection}{\numberline {2.3.16}最近公共祖先（LowestCommonAncestor）}{42}{subsubsection.2.3.16}%
\contentsline {subsubsection}{\numberline {2.3.17}翻转二叉树（InvertTree）}{43}{subsubsection.2.3.17}%
\contentsline {subsubsection}{\numberline {2.3.18}实现多个二叉树管理}{43}{subsubsection.2.3.18}%
\contentsline {subsubsection}{\numberline {2.3.19}二叉树的文件读写}{44}{subsubsection.2.3.19}%
\contentsline {subsection}{\numberline {2.4}系统测试}{45}{subsection.2.4}%
\contentsline {subsubsection}{\numberline {2.4.1}创建二叉树（CreateBiTree）}{45}{subsubsection.2.4.1}%
\contentsline {subsubsection}{\numberline {2.4.2}销毁二叉树（DestroyBiTree）}{46}{subsubsection.2.4.2}%
\contentsline {subsubsection}{\numberline {2.4.3}清空二叉树（ClearBiTree）}{46}{subsubsection.2.4.3}%
\contentsline {subsubsection}{\numberline {2.4.4}判定空二叉树（BiTreeEmpty）}{47}{subsubsection.2.4.4}%
\contentsline {subsubsection}{\numberline {2.4.5}求二叉树深度（BiTreeDepth）}{48}{subsubsection.2.4.5}%
\contentsline {subsubsection}{\numberline {2.4.6}查找结点（LocateNode）}{48}{subsubsection.2.4.6}%
\contentsline {subsubsection}{\numberline {2.4.7}结点赋值（Assign）}{49}{subsubsection.2.4.7}%
\contentsline {subsubsection}{\numberline {2.4.8}获得兄弟结点（GetSibling）}{50}{subsubsection.2.4.8}%
\contentsline {subsubsection}{\numberline {2.4.9}插入结点（InsertNode）}{51}{subsubsection.2.4.9}%
\contentsline {subsubsection}{\numberline {2.4.10}删除结点（DeleteNode）}{52}{subsubsection.2.4.10}%
\contentsline {subsubsection}{\numberline {2.4.11}前序遍历（PreOrderTraverse）}{53}{subsubsection.2.4.11}%
\contentsline {subsubsection}{\numberline {2.4.12}中序遍历（InOrderTraverse）}{54}{subsubsection.2.4.12}%
\contentsline {subsubsection}{\numberline {2.4.13}后序遍历（PostOrderTraverse）}{54}{subsubsection.2.4.13}%
\contentsline {subsubsection}{\numberline {2.4.14}按层遍历（LevelOrderTraverse）}{55}{subsubsection.2.4.14}%
\contentsline {subsubsection}{\numberline {2.4.15}最大路径和（MaxPathSum）}{56}{subsubsection.2.4.15}%
\contentsline {subsubsection}{\numberline {2.4.16}最近公共祖先（LowestCommonAncestor）}{56}{subsubsection.2.4.16}%
\contentsline {subsubsection}{\numberline {2.4.17}翻转二叉树（InvertTree）}{57}{subsubsection.2.4.17}%
\contentsline {subsubsection}{\numberline {2.4.18}多个二叉树管理}{58}{subsubsection.2.4.18}%
\contentsline {subsubsection}{\numberline {2.4.19}二叉树的文件读写}{61}{subsubsection.2.4.19}%
\contentsline {subsubsection}{\numberline {2.4.20}退出程序}{63}{subsubsection.2.4.20}%
\contentsline {subsection}{\numberline {2.5}实验小结}{64}{subsection.2.5}%
\contentsline {section}{\numberline {3}课程的收获和建议}{65}{section.3}%
\contentsline {subsection}{\numberline {3.1}基于顺序存储结构的线性表实现}{65}{subsection.3.1}%
\contentsline {subsection}{\numberline {3.2}基于二叉链表的二叉树实现}{65}{subsection.3.2}%
\contentsline {section}{参考文献}{67}{section*.12}%
\contentsline {section}{附录A 基于顺序存储结构线性表实现的源程序}{67}{section*.13}%
\contentsline {section}{附录B 基于二叉链表二叉树实现的源程序}{86}{section*.14}%
